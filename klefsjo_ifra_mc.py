# -*- coding: utf-8 -*-
"""Untitled35.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nlsNotAsfgjvNKuVG7l6L5uaYyHjbek8
"""

def klefsjo_ifra_mc(x, alternative="two-sided", exact=False, min_reps=100, max_reps=1000, delta=1e-3):
    def find_ifra(x):
        x_sorted = np.sort(x)
        n = len(x_sorted)
        D = n * x_sorted[0]  # Find D_1
        beta = (-1 + (1 - (3 * n) - (3 * (n**2))) + \
               (2 * n) + (3 * (n**2)) + (n**3)) / 6 #beta_{1}

        for i in range(1, n):
            D = np.append(D, (n - i) * (x_sorted[i] - x_sorted[i - 1]))  # Calculate alpha_i
            beta = np.append(beta, ((2 * ((i + 1)**3)) - (3 * ((i + 1)**2)) + \
                                    (i + 1) * (1 - (3 * n) - (3 * (n**2))) + \
                                    (2 * n) + (3 * (n**2)) + (n**3)) / 6)

        B = np.sum(beta * D) / np.sum(D)
        B_star = B * np.sqrt(210 / (n ** 5))

        return B_star

    def p_g_mc(B_star, n, min_reps=100, max_reps=1000, delta=1e-3):
        dsn = []
        for i in range(min_reps):
          dsn += [find_ifra(np.random.exponential(scale=1, size=n))]

        reps = min_reps
        while reps <= max_reps:
            p = len(list(filter(lambda f: f > B_star, dsn))) / reps
            dsn += [find_ifra(np.random.exponential(scale=1, size=n))]

            if np.abs(p-len(list(filter(lambda f: f > B_star, dsn))) / reps) <= delta:
                return p

            reps += 1
        print("Warning: reached maximum reps without converging within delta")
        return p

    def p_l_mc(B_star, n, min_reps=100, max_reps=1000, delta=1e-3):
        dsn = []
        for i in range(min_reps):
          dsn += [find_ifra(np.random.exponential(scale=1, size=n))]

        reps = min_reps
        while reps <= max_reps:
            p = len(list(filter(lambda f: f < B_star, dsn))) / reps
            dsn += [find_ifra(np.random.exponential(scale=1, size=n))]

            if np.abs(p - len(list(filter(lambda f: f < B_star, dsn))) / reps) <= delta:
                return p

            reps += 1
        print("Warning: reached maximum reps without converging within delta")
        return p

    alternative = alternative.lower()
    if alternative not in ["two-sided", "dfra", "ifra"]:
        raise ValueError("alternative must be 'two-sided', 'dfra', or 'ifra'")

    B_star = find_ifra(x)
    n = len(x)

    if n >= 9 and not exact:

        if alternative == "dfra":
            p = norm.cdf(B_star)
        elif alternative == "ifra":
            p = 1 - norm.cdf(B_star)
        elif alternative == "two-sided":
            p = 2*(1 - norm.cdf(abs(B_star)))

        return {"B": B_star, "prob": p}

    # Exact Test
    if alternative == "dfra":
        p = p_l_mc(B_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta)

    if alternative == "ifra":
        p = p_g_mc(B_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta)

    if alternative == "two-sided":
        p = 2 * min(p_l_mc(B_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta),
                    p_g_mc(B_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta))

    return {"B": B_star, "prob": p}