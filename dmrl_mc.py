# -*- coding: utf-8 -*-
"""Untitled35.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nlsNotAsfgjvNKuVG7l6L5uaYyHjbek8
"""

import numpy as np
from scipy.stats import norm

def dmrl_mc(x, alternative="two-sided", exact=False, min_reps=100, max_reps=1000, delta=1e-3):

    def find_V_star(x):
        x_ord = np.sort(x)
        n = len(x_ord)
        i = np.arange(1, n+1)
        c_i = ((4/3)*(i**3)) - (4*n*(i**2)) + (3*(n**2)*i) - ((n**3)/2) + ((n**2)/2) - ((i**2)/2) + (i/6)
        V = np.sum(c_i*x_ord)/(n**4)
        V_star = V/np.mean(x_ord)
        return V_star

    def p_g_mc(V_star, n, min_reps=100, max_reps=1000, delta=1e-3):
        dsn = []
        for i in range(min_reps):
          dsn += [find_V_star(np.random.exponential(scale=1, size=n))]

        reps = min_reps
        while reps <= max_reps:
            p = len(list(filter(lambda f: f > V_star, dsn))) / reps
            dsn += [find_V_star(np.random.exponential(scale=1, size=n))]

            if np.abs(p-len(list(filter(lambda f: f > V_star, dsn))) / reps) <= delta:
                return p

            reps += 1
        print("Warning: reached maximum reps without converging within delta")
        return p

    def p_l_mc(V_star, n, min_reps=100, max_reps=1000, delta=1e-3):
        dsn = []
        for i in range(min_reps):
          dsn += [find_V_star(np.random.exponential(scale=1, size=n))]

        reps = min_reps
        while reps <= max_reps:
            p = len(list(filter(lambda f: f < V_star, dsn))) / reps
            dsn += [find_V_star(np.random.exponential(scale=1, size=n))]

            if np.abs(p-len(list(filter(lambda f: f < V_star, dsn))) / reps) <= delta:
                return p

            reps += 1
        print("Warning: reached maximum reps without converging within delta")
        return p

    alternative = alternative.lower()
    if alternative not in ["two-sided", "dmrl", "imrl"]:
        raise ValueError("alternative must be 'two-sided', 'dmrl', or 'imrl'")

    V_star = find_V_star(x)
    n = len(x)

    if n >= 9 and not exact:
        V_prime = np.sqrt(210*n)*V_star

        if alternative == "imrl":
            p = norm.cdf(V_prime)
        elif alternative == "dmrl":
            p = 1 - norm.cdf(V_prime)
        elif alternative == "two-sided":
            p = 2*(1 - norm.cdf(V_prime))

        return {"V": V_prime, "prob": p}

    # Exact Test
    if alternative == "imrl":
        p = p_l_mc(V_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta)

    if alternative == "dmrl":
        p = p_g_mc(V_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta)

    if alternative == "two.sided":
        p = 2 * min(p_l_mc(V_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta),
                    p_g_mc(V_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta))

    print("V*=", V_star, "\n", "p=", p,"\n")
    return V_star, p