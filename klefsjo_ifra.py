# -*- coding: utf-8 -*-
"""Untitled35.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nlsNotAsfgjvNKuVG7l6L5uaYyHjbek8
"""

def klefsjo_ifra(x, alternative="two-sided", exact=False):
    def find_ifra(x):
        x_sorted = np.sort(x)
        n = len(x_sorted)
        D = n * x_sorted[0]  # Find D_1
        beta = (-1 + (1 - (3 * n) - (3 * (n**2))) + \
               (2 * n) + (3 * (n**2)) + (n**3)) / 6 #beta_{1}

        for i in range(1, n):
            D = np.append(D, (n - i) * (x_sorted[i] - x_sorted[i - 1]))  # Calculate alpha_i
            beta = np.append(beta, ((2 * ((i + 1)**3)) - (3 * ((i + 1)**2)) + \
                                    (i + 1) * (1 - (3 * n) - (3 * (n**2))) + \
                                    (2 * n) + (3 * (n**2)) + (n**3)) / 6)

        B = np.sum(beta * D) / np.sum(D)
        B_star = B * np.sqrt(210 / (n ** 5))

        return B_star

    def prob_klefsjo(t, n):
        """
        Calculates the probability P(A > t).

        Parameters:
        t (float): The value of the IFR statistic.
        n (int): The sample size.

        Returns:
        float: The probability P(A > t).
        """
        j = np.arange(1, n + 1)
        coe  = ((2 * (j**3)) - (3 * (j**2)) + j * (1 - (3 * n) - (3 * (n**2))) + \
              (2 * n) + (3*(n**2)) + (n**3)) / 6
        t = t / (np.sqrt(210 / (n**5))) #convert from B* to B

        def delta(coeff, t):
            """
            Helper function to calculate the delta_j.
            """
            return 1 if coeff > t else 0

        sum_val = 0
        for j in range(n):
            prod_val = 1
            for i in range(n):
                if i != j:
                    prod_val *= (((coe[j] - t) / (coe[j] - coe[i])) * delta(coe[j], t))
            sum_val += prod_val
        return sum_val


    alternative = alternative.lower()
    if alternative not in ["two-sided", "dfra", "ifra"]:
        raise ValueError("alternative must be 'two-sided', 'dfr', or 'ifr'")

    B_star = find_ifra(x)
    n = len(x)

    # large sample approximation
    if n >= 9 and not exact:

      if alternative == "dfra":
          p = norm.cdf(B_star)
      elif alternative == "ifra":
          p = 1 - norm.cdf(B_star)
      elif alternative == "two-sided":
          p = 2*(1 - norm.cdf(abs(B_star)))

      return {"B": B_star, "prob": p}


    # Exact Test
    if alternative == "dfra":
        p = 1 - prob_klefsjo(B_star, n)
    if alternative == "ifra":
        p = prob_klefsjo(B_star, n)
    if alternative == "two-sided":
        p = 2 * min(1 - prob_klefsjo(B_star, n), prob_klefsjo(B_star, n))


    if p is None:
      print("Large Sample Approximation Used because of Equal Coefficients")
      # Recalculate with large sample approx.
      if alternative == "dfra":
          p = norm.cdf(B_star)
      if alternative == "ifra":
          p = 1 - norm.cdf(B_star)
      if alternative == "two-sided":
          p = 2 * (1 - norm.cdf(abs(B_star)))

    return {"B": B_star, "prob": p}