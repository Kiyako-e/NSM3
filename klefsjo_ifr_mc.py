# -*- coding: utf-8 -*-
"""Untitled35.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nlsNotAsfgjvNKuVG7l6L5uaYyHjbek8
"""

def klefsjo_ifr_mc(x, alternative="two-sided", exact=False, min_reps=100, max_reps=1000, delta=1e-3):
    def find_ifr(x):
        x_sorted = np.sort(x)
        n = len(x_sorted)
        D = n * x_sorted[0]  # Find D_1
        n1 = n + 1  # Use this in calculating alpha
        alpha = ((n1 ** 3) - (3 * (n1 ** 2)) + (2 * n1)) / 6

        for i in range(1, n):
            D = np.append(D, (n - i) * (x_sorted[i] - x_sorted[i - 1]))  # Calculate alpha_i
            alpha = np.append(alpha, (((n1 ** 3) * (i + 1)) - \
                    (3 * (n1 ** 2) * ((i + 1) ** 2)) + (2 * n1 * ((i + 1) ** 3))) / 6)

        A = np.sum(alpha * D) / np.sum(D)
        A_star = A * np.sqrt(7560 / (n ** 7))

        return A_star

    def p_g_mc(A_star, n, min_reps=100, max_reps=1000, delta=1e-3):
        dsn = []
        for i in range(min_reps):
          dsn += [find_ifr(np.random.exponential(scale=1, size=n))]

        reps = min_reps
        while reps <= max_reps:
            p = len(list(filter(lambda f: f > A_star, dsn))) / reps
            dsn += [find_ifr(np.random.exponential(scale=1, size=n))]

            if np.abs(p-len(list(filter(lambda f: f > A_star, dsn))) / reps) <= delta:
                return p

            reps += 1
        print("Warning: reached maximum reps without converging within delta")
        return p

    def p_l_mc(A_star, n, min_reps=100, max_reps=1000, delta=1e-3):
        dsn = []
        for i in range(min_reps):
          dsn += [find_ifr(np.random.exponential(scale=1, size=n))]

        reps = min_reps
        while reps <= max_reps:
            p = len(list(filter(lambda f: f < A_star, dsn))) / reps
            dsn += [find_ifr(np.random.exponential(scale=1, size=n))]

            if np.abs(p-len(list(filter(lambda f: f < A_star, dsn))) / reps) <= delta:
                return p

            reps += 1
        print("Warning: reached maximum reps without converging within delta")
        return p

    alternative = alternative.lower()
    if alternative not in ["two-sided", "dfr", "ifr"]:
        raise ValueError("alternative must be 'two-sided', 'dfr', or 'ifr'")

    A_star = find_ifr(x)
    n = len(x)

    if n >= 9 and not exact:

        if alternative == "dfr":
            p = norm.cdf(A_star)
        elif alternative == "ifr":
            p = 1 - norm.cdf(A_star)
        elif alternative == "two-sided":
            p = 2*(1 - norm.cdf(abs(A_star)))

        return {"V": A_star, "prob": p}

    # Exact Test
    if alternative == "dfr":
        p = p_l_mc(A_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta)

    if alternative == "ifr":
        p = p_g_mc(A_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta)

    if alternative == "two-sided":
        p = 2 * min(p_l_mc(A_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta),
                    p_g_mc(A_star, n, min_reps=min_reps, max_reps=max_reps, delta=delta))

    return A_star, p