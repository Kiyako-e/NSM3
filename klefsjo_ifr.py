# -*- coding: utf-8 -*-
"""Untitled35.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nlsNotAsfgjvNKuVG7l6L5uaYyHjbek8
"""

import numpy as np
from scipy.stats import norm

def find_ifr(x):
    """
    Calculates the IFR statistic A*.

    Parameters:
    x (np.ndarray): Input data.

    Returns:
    float: The IFR statistic A*.
    """
    x_sorted = np.sort(x)
    n = len(x_sorted)
    D = n * x_sorted[0]  # Find D_1
    n1 = n + 1  # Use this in calculating alpha
    alpha = ((n1 ** 3) - (3 * (n1 ** 2)) + (2 * n1)) / 6

    for i in range(1, n):
        D = np.append(D, (n - i) * (x_sorted[i] - x_sorted[i - 1]))  # Calculate alpha_i
        alpha = np.append(alpha, (((n1 ** 3) * (i + 1)) - \
                (3 * (n1 ** 2) * ((i + 1) ** 2)) + (2 * n1 * ((i + 1) ** 3))) / 6)

    A = np.sum(alpha * D) / np.sum(D)
    A_star = A * np.sqrt(7560 / (n ** 7))

    return A_star

def prob_klefsjo(t, n):
    """
    Calculates the probability P(A > t).

    Parameters:
    t (float): The value of the IFR statistic.
    n (int): The sample size.

    Returns:
    float: The probability P(A > t).
    """
    n1 = n + 1  # For readability in the formula
    j = np.arange(1, n + 1)
    coe = (((n1 ** 3) * j) - (3 * (n1 ** 2) * (j ** 2)) + (2 * n1 * (j ** 3))) / 6  # Calculate the a's
    t = t / np.sqrt(7560 / (n ** 7))  # Convert from A* to A

    def delta(coeff, t):
        """
        Helper function to calculate the delta_j.
        """
        return 1 if coeff > t else 0

    sum_val = 0
    for j in range(n):
        prod_val = 1
        for i in range(n):
            if i != j:
                prod_val *= (((coe[j] - t) / (coe[j] - coe[i])) * delta(coe[j], t))
        sum_val += prod_val
    return sum_val

def klefsjo_ifr(x, alternative="two.sided", exact=False):
    """
    Performs the Klefsjo's IFR test.

    Parameters:
    x (np.ndarray): Input data.
    alternative (str): The alternative hypothesis, can be "two.sided", "dfr", or "ifr".
    exact (bool): Whether to use the exact test or the large sample approximation.

    Returns:
    dict: A dictionary containing the IFR statistic A* and the p-value.
    """
    alternative = alternative.lower()
    if alternative not in ["two.sided", "dfr", "ifr"]:
        raise ValueError("alternative must be \"two.sided\", \"dfr\" or \"ifr\"")

    A_star = find_ifr(x)
    n = len(x)

    # Large sample approximation
    if n >= 9 and not exact:
        if alternative == "dfr":
            p = norm.cdf(A_star)
        elif alternative == "ifr":
            p = 1 - norm.cdf(A_star)
        else:  # "two.sided"
            p = 2 * (1 - norm.cdf(abs(A_star)))

        return A_star, p

    # Exact Test
    if alternative == "dfr":
        p = 1 - prob_klefsjo(A_star, n)
    if alternative == "ifr":
        p = prob_klefsjo(A_star, n)
    if alternative == "two.sided":
        p = 2 * min(1 - prob_klefsjo(A_star, n), prob_klefsjo(A_star, n))

    if p is None:
      print("Large Sample Approximation Used because of Equal Coefficients")
      # Recalculate with large sample approx.
      if alternative == "dfr":
          p = norm.cdf(A_star)
      if alternative == "ifr":
          p = 1 - norm.cdf(A_star)
      if alternative == "two.sided":
          p = 2 * (1 - norm.cdf(abs(A_star)))

    return A_star, p